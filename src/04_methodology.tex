\section{Архитектура на системот}

Техничкото решение се состои од претходно наведените технологии, апликацијата е организирана од повеќе различни сервиси кои се користат за да се достигни крајната цел на апликацијата, а тоа е да им овозможи на корисници да ги хостираат брзо и едноставно своите апликации.

Апликацијата е главно базирана врз основата на Kubernetes платформата, и врз основа на тоа се изградени структурата на базата на податоци, тука е вклучена комуникацијата со самите сервиси што се користат во решението.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.75\linewidth]{assets/infrastructure.png}
  \caption{Слоеви на инфраструктурата}
  \label{fig:architecture-layers}
\end{figure}

Како што може да се види на слика \ref{fig:architecture-layers} решението е поделено на неколку слоеви, првиот слој е слојот до кој корисникот има пристап и има директна интеракција, односно ова би било слојот кој се занимава со мрежата, еден слој подолу се наоѓа главната апликација која исто така може да е дел од Kubernetes слојот, апликацијата комуницира со Kubernetes слојот, каде што се наоѓаат поможните сервиси кои го овозможуваат градењето, хостирањето и прегледот на корисничките апликации, самите кориснички апликации немаат никаква поврзаност со главната апликација, и се менаџираат од страна на Kubernetes платформата, потоа најдолниот слој претставува каде Kubernetes платформата е хостирана, ова може да биде локален сервер, cloud платформа, виртуелни машини.

\subsection{Сервиси}

Вклучено во сервисите кои се користат се:

\begin{itemize}
  \item Kubernetes
  \item Container registry (Docker)
  \item Keycloak
  \item WebDAV
  \item Nginx Ingress controller
  \item PostgreSQL
  \item kaniko
\end{itemize}

Овие технологии овозможуваат на решението да чува податоци, да менаџира со самата платформа и да ја користи за хостирање на други апликации, самата платформа дозволува комуникација помеѓу овие сервиси, исто така ни овозможуваат поголема безбедност при што тука го имаме keycloak кој нуди автентикација.

\subsection{Преглед на системот}

На слика \ref{fig:service-arch}. јасно можe да се види комуникацијата помеѓу овие сервиси, прво се започнува со корисникот, кој ја пристапува страницата за хостирање и го добива корисничкиот интерфејс.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\linewidth]{assets/СервиснаАрхитектура.png}
  \caption{Преглед на сервисите}
  \label{fig:service-arch}
\end{figure}

Потоа корисничкиот интерфејс го пренасочува на страница каде се бара негова автентикација преку користење на keycloak сервисот, откако корисникот ќе се најави, добива пристап до апликацијата, и можe да ги види само своите податоци, во позадина се користи keycloak со OpenID и OAuth 2.0 протоколот, при што апликацијата го чита токенот и знае кој клиент е најавен и им овозможува контрола на корисниците врз своите апликации.

Откако корисникот ќе се најави, има пристап до останатите сервиси, при што има можност да ја пристапи главната апликација и да хостира свои апликации, при што корисникот има избор од 2 начини, еден од нив е хостирање од со обезбедување на извршна датотека, при овој користење на овој тек на апликацијата се користи WebDAV сервисот кој е хостиран во околината за да ги зачува овие датотеки, а доколку се оди со вториот начин, а тоа е со користење на git репо, главната апликацијата прави директно повик до околината во која е хостирана и се започнува со закажување на нова задача која која ја гради сликата за контејнерот со користење на kaniko, оваа алатка добива шаблон како да ја изгради сликата, во првиот случај со извршната датотека ја презема датотеката од WebDAV сервисот, ја гради сликата и ја зачувува во регистарот за слики кој исто така е хостиран во околината, во вториот случај без извршна датотека според дадениот шаблон ја изградува извршната датотека и ја гради сликата и повторно ја складира во регистарот за слики.

Во периодот на градење на сликите апликацијата има можност да ги следи логовите додека се гради апликацијата и да ги прикажи на корисникот користејќи WebSocket протоколот, кога ќе се заврши со градење на корисникот му се прикажуваат сите изградени слики на корисничкиот интерфејс.

Во следниот чекор корисникот има можност да креира распоред на апликацијата која подоцна се хостира на самата платформа за ова корисникот ја одбира сликата и нејзината верзија која сака да се хостира и апликацијата моменталната состојба ја зачувува во база на податоци, во овој случај за таа цел се користи postgreSQL, откакко се зачува состојбата апликацијата продолжува со креирање на ресурсите на самата Kubernetes платформа, при тоа се овозможува следење на логови и статусот на апликацијата.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\linewidth]{assets/db2.png}
  \caption{Релациски дијаграм на ентитетите}
  \label{fig:entity-relation-diagram}
\end{figure}

Како што можe да се види на слика \ref{fig:entity-relation-diagram}. Апликациите на еден корисник спаѓаат под еден така наречен именски простор (namespace), секој корисник со најава добива еден именски простор, и сите апликации спаѓаат под негова контрола, корисник теоретски може да има повеќе именски простори, но решението креира и работи со само еден, при што не дозволува креирање на повеќе, и секој корисник кој се најавува на системот автоматски добива еден именски простор за сите апликации, доколку корисник сака да ги поврзи своите апликации добива линк од платформата за интерна комуникација, за тоа се користат сервиси од Kubernetes алатката.

Покрај апликациите и конфигурациите на корисниците тука исто така спаѓаат и основните слики, кои се користат како шаблони за креирање на кориснички апликации, при тоа овој дизајн му овозможува на администратори на апликацијата поголема флексибилност, со што се дава можност во иднина да се имплементираат останати технологии покрај Java, без прилагодување на самото решение, покрај нови технологии ова му овозможува на администратор да додади и останати готови алтернативни сервиси, како што се бази на податоци, брокери за пораки, и останати помошни сервиси, при тоа со развивање на овие дополнителни основни слики решението е доволно флексибилно да им овозможува на корисници потполна моќ да развијат и хостираат било каква апликација.

Именскиот простор е врзан со сервисот за автентикација, каде што за секој корисник се креира еден именски простор, поради тоа што сервисот за автентикација е екстерен и има своја база на податоци, решението знае само дали корисникот е автентициран и добива контекст за неговиот идентитет, користејќи го ова се креира ентитет во базата на податоци во кој се чува именски простор поврзан со секој корисник, ова го поврзува корисникот со сите негови апликации.


\section{Кориснички интерфејс}

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\linewidth]{assets/apps.png}
  \caption{Преглед на апликации}
  \label{fig:applications}
\end{figure}

Корисничкиот интерфејс за корисниците се состои од една контролна табла каде секој клиент ги гледа своите апликации, сите апликации во овој простор припаѓаат на еден клиент, и секогаш има можност за самите да комуницираат помеѓу себе како сервиси.

Потоа корисничкиот интерфејс содржи и дел за документација, каде се опишуваат ограничувањата на системот при што клиентот кој ја користи алатката може да се прилагоди врз системот.

За крај исто така има и панел за администрација кој е достапен само до корисник со соодветна улога, тука администратор има пристап до можности за градење на контејнери кои се доста флексибилни и би му овозможиле на администратор да додади многу повеќе функционалности, неколку примери:

\begin{itemize}
  \item додавање на поддршка за креирање на бази на податоци
  \item поддршка за други алатки како RabbitMQ, kafka, keycloak итн.
  \item Додавање на поддршка за автентицирани Git репозиториуми
  \item Додавање на поддршка за останати јазици или алатки за градење
\end{itemize}

Потоа сите овие апликации може да комуницираат со сите останати апликации, во рамки на Kubernetes, при што би се користеле сервиси за интерна комуникација.

\subsection{Апликации и слики за контејнери}

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\linewidth]{assets/keycloak.png}
  \caption{Автентикација со keycloak}
  \label{fig:keycloak}
\end{figure}

На корисничкиот интерфејс апликации се нарекуваат сликите за контејнерите, при што корисник прво создава слика, при што од него се бара само името на новата слика, потоа добива опција за да направи објава на нова верзија од истата, и има две опции:

\begin{itemize}
  \item Прикачување на извршна датотека
  \item Градење на извршната датотека
\end{itemize}

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\linewidth]{assets/create-app.png}
  \caption{Дијалогот за создавање на нова слика}
  \label{fig:create-app}
\end{figure}

Корисникот има можност да креира слика со специфицирање на сите полиња кои се под целосна контрола на администратор, администратор може да додади или одземи одредени полиња, целата состојба за ова се чува во базата на податоци, со избор на јазик и вид на слика корисникот има можност да добие сосема различни полиња и опции.

\subsection{Прикачување на извршна датотека}

Во овој случај од страна на корисникот се бара извршна датотека, при што е потребно самиот да ја изгради и да ја прикачи, исто така има дополнителни опции за тоа која верзија на одбраниот јазик да се користи.

Во овој случај решението е доста флексибилно, им дозволува на клиентите да користат која било алатка за да изградат извршна датотека, и го прави креирањето на слики доста едноставно.

Во случајот на Java како што можe да се види на слика \ref{fig:release-app-exe}, од корисникот се бара „\textit{jar}“ извршна датотека, овие полиња зависат од страна на администраторот, при што може во случај да се користи друг јазик да се бара друг вид на датотека, како што во \textbf{.NET} можe да се побара „\textit{.NET assembly}“ или само „\textit{.zip}“ датотека, која подоцна би се искористила во самиот процес на градење.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\linewidth]{assets/release-app-exe1.png}
  \caption{Креирање на слика со прикачување на извршна датотека}
  \label{fig:release-app-exe}
\end{figure}

\subsection{Градење на извршната датотека}

Решението им овозможува на корисници градење на извршната датотеката, при што за оваа цел се користи „\textbf{Git}“, но системот не е лимитиран на само оваа алатка, доколку администратор сака да додади повеќе алатки тоа апликацијата го овозможува,

Во овој случај како што можe да се видe на слика \ref{fig:release-app-git}. од корисникот се бараат повеќе информации, како што се која алатка за градење ќе се користи, притоа исто така корисник има контрола врз некои претходно дефинирани вариабли кои се користат за градење на извршната датотека, како што можe да се види на сликата, од корисникот се бара URL од Git репозиториумот, една лимитација на ова решение, односно на дефиницијата за градење на слика за контејнер е дека има поддршка само за јавни репозиториуми, но ова многу лесно можe да се надмине, со додавање на дополнителни вариабли за автентикација, како на пример за токен.

Дополнително, од корисникот се бараат директориумот од каде да се започни со градење, ова се бара во случај да организацијата на проектот не е стандардна, или во еден репозиториум се наоѓаат повеќе проекти, потоа се бара патот до `jar` фајлот кој на крај се користи за започнување на апликацијата и за крај им се дозволува на корисници да пратат дополнителни аргументи на алатката кои им се потребни за да го изградат својот проект или апликација.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\linewidth]{assets/release-app-git1.png}
  \caption{Креирање на слика со градење на извршна датотека}
  \label{fig:release-app-git}
\end{figure}

\subsection{Изданија на апликација}

Сите изданија од апликацијата се прегледни на страната за информации за апликацијата, на слика \ref{fig:releases}. можe да се види издание со верзија 1.0.0, при што ова издание е направено со прикачување на извршна датотека.

На оваа страница им се овозможува на корисници брзо издавање на апликација, со претходно наведените варијабли за некоја постара верзија, исто така и има преглед на претходно наведените варијабли.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\linewidth]{assets/releases.png}
  \caption{Изданија на апликација}
  \label{fig:releases}
\end{figure}

Корисникот можe во реално време да ги следи логовите од градењето на сликата, доколку дојди до проблем има увид во што точно се случило, доколку е проблемот од негова страна можe да го поправи, како на пример грешно поставена вариабла, ова можe да се види на слика.

Следењето на логови е овозможено со веб-сокети при што системот кога ќе добие веб-сокет повик се чува сесијата, и доколку има градење на датотека вкулечно за прикачува таму таа сесија, доколку нема ништо моментално се бараат логовите во базата на податоци, бидејќи тие откако ќе заврши градењето на сликата се губат тие логови и е потребно да се зачуваат, тие се чуваат во базата на податоци, а за логови се користи Kubernetes интерфејсот, при што се слуша на секој запис на лог и се препраќа подоцна во системот, каде се чува во меморија, а подоцна се праќа и на корисникот, кој можe да го гледа во реално време.

Корисникот исто така можe да го следи самиот статус на градење на сликата, додека сликата се гради наместо зелената ознака се прикажува на корисник знак за вчитување, доколку дојди до грешка на корисникот им се прикажува знак за грешка.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\linewidth]{assets/release-logs.png}
  \caption{Логови за изградба на слика за контејнер}
  \label{fig:release-logs}
\end{figure}

\subsection{Преглед на групи на хостирани апликации}

Групите се користат за подобро организирање на апликациите, корисник мора пред да ја хостира некоја апликација да ја стави во група, групата се креира доста едноставно, се бара од корисникот само името на групата, доколку корисникот сака да избриши цела група на хостирани апликации тоа би ги избришало сите ресурси поврзани со таа група, прегледот е прикажан на слика \ref{fig:groups}.

Секој корисник има можност да поседува повеќе групи, овие групи главно се користат да се распределат логички апликациите едни од други, но не постои лимитација во интерната комуникацијата помеѓу повеќе апликации, доколку апликациите се наоѓаат во еден именски простор корисникот може да го користи директниот линк до сервисот за таа апликација, но доколку корисникот сака да оствари комуникација помеѓу апликации во различни сервиси, или да комуницира со друга апликацијата од во рамки на самата платформа, тоа можи да го направи со користење на целосното име (DNS) кое платформата го доделува на самите сервиси, ова е илустрирано со код \ref{code:k8s-service-dns}.

\begin{lstlisting}[language=bash, caption={Повик на сервис во различен именски простор}, label={code:k8s-service-dns}]
#!/usr/bin/env bash

NAMESPACE="4C212F98-199F-47EE-BD60-7678B990652A"
SERVICE_NAME="app-svc"
SERVICE_URL="http://$SERVICE_NAME.$NAMESPACE.svc.cluster.local"

curl $SERVICE_URL
\end{lstlisting}

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\linewidth]{assets/groups.png}
  \caption{Преглед на групи}
  \label{fig:groups}
\end{figure}

\subsection{Преглед на распоредувања на апликации}

Едно распоредување (deployment) на апликација значи дека таа апликација е хостирана, прегледот на хостираните апликации е претставен на слика \ref{fig:deployments}, на овој преглед на корисниците им се овозможува да управуваат со својата апликација.

Опциите кои им се нудат на корисниците се следните:

\begin{enumerate}
  \item Запирање и започнување на апликацијата.
  \item Преглед на логовите во апликацијата во реално време.
  \item Целосно бришење на хостираната апликација
  \item Приспособување на конфигурацијата за хостирање на самата апликација (промена на верзија, патека од линкот, конфигурациски опции, итн...)
  \item Преглед на интерниот линк до апликацијата во самиот кластер
\end{enumerate}

Најчеста промена што би била очекувана од страна на корисници е правење на надградби на апликацијата, тоа би значело промена на верзијата и конфигурацијата, при тоа треба да се има во предвид дека хостираната апликација при промена на конфигурација се запира и се креира нова апликација.

За безбедност и тестирање корисникот може во било кое време многу лесно да хостира две верзии од истата апликација, но доколку апликацијата побарува повеќе сервиси потребно би било сите сервиси да се хостирани по втор пат, или да се користат истите сервиси од двете апликации, во случај да апликациите имаат многу зависности ова ја зголемува комплексноста за хостирање, откако корисникот заврши со тестирање има можност да го промени линкот од старата верзија, при што би се тргнала од употреба и новата верзија на апликацијата да го добие стариот линк со што би се заменила оваа апликација со новата верзија, и старата верзија може да се избриши.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\linewidth]{assets/deployment-loading.png}
  \caption{Преглед на распоредувања}
  \label{fig:deployments}
\end{figure}

Корисникот во секој момент има можност да ги гледа логовите од својата апликација, доколку платформата успешно ги креира ресурсите и апликацијата е започната логовите се видливи од страна на корисникот, за оваа цел не се зачувува состојбата на логовите во базата на податоци и секогаш се земаат во реално време.

Секогаш кога апликацијата добие нови логови со користејќи отворена конекција преку WebSocket протоколот корисничкиот интерфејс чека од серверот одговор и добива нов лог од самата платформа.

Ова им овозможува на корисниците евиденција во своите апликации, доколку настанат грешки корисниците можат да ги откријат со користење на логови.

Преглед од логовите од една апликација се прикажани на слика \ref{fig:deployment-logs}.

Некогаш тоа не е доволно за дебагирање на самата апликација, но тоа е една лимитација од користењето на оваа платформа, главната цел би била едноставност за хостирање, со тоа се жртвува прегледноста за грешки во апликациите кои се хостираат.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\linewidth]{assets/deployment-logs.png}
  \caption{Преглед на логови од хостирана апликација}
  \label{fig:deployment-logs}
\end{figure}

\subsection{Креирање на распоредувања за хостирање на апликации}

Прегледот за креирање на распоредувања за хостирање на апликации е претставен на слика \ref{fig:deployment-create}, на оваа слика се прикажани полињата кои се потребни за Kubernetes платформата да се хостира една апликација.

Од страна на корисникот се бара претходно да има креирано група во која ќе биде сместено ова хостирање, и да има обезбедено изградена верзија од апликацијата која сака да ја хостира, потоа се бара од нивна страна поставки за самата платформа, односно како ќе се вика самиот сервис, од ова зависи интерната патека до тој сервис.

Корисникот има можност да одбери својата хостирана апликацијата да биде изложена на надворешниот свет, при тоа за оваа цел како дел од изложената патека се користи името на именскиот простор за тој корисник, а останатиот дел од патеката го одредува корисникот, оваа лимитација е воведена во случај на два корисници да одберат именски простор или патека што се поклопува, доколку се случи ова би дошло до грешка од страна на платформата, за да се спречи ова се генерира еден именски простор за секој корисник, и е дел од самата патека.

За крај корисникот има можност да специфицира конфигурациски полиња за својата околина, овие конфигурации подоцна се испраќаат до апликацијата, каде апликацијата можe да одреди како ќе ги прочита и користи, за оваа цел за полесно организирање на овие конфигурациски полиња постои и дијалог со подобар преглед за прилагодување на овие полиња, тоа е прикажано на слика \ref{fig:deployment-create-properties}.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\linewidth]{assets/deployment-create.png}
  \caption{Преглед за креирање на распоредувања за хостирање}
  \label{fig:deployment-create}
\end{figure}

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\linewidth]{assets/deployment-create-properties.png}
  \caption{Преглед за прилагодување на конфигурациски полиња}
  \label{fig:deployment-create-properties}
\end{figure}

\subsection{Основни шаблони за градење на апликации}

На слика \ref{fig:base-image-view}. е прикажан преглед на основните шаблони за градење на апликации, овие шаблони се користат за да се олесни градењето на апликации, при што корисникот има можност да избере од некој од овие шаблони и да го користи за градење на својата апликација.

Администратор има целосна контрола врз овие шаблони, при тоа една од лимитациите е тоа што е потребно да се направи шаблон за секоја верзија на програмскиот јазик или алатката за градење на апликации, исто така потребно е за секоја алатка да се прави посебен шаблон.

Но главна предност е тоа што администратор може да додава шаблони за технологии за кои иницијално ова решение не е прилагодено.

Корисник одбира еден шаблон од овие за да ја гради својата апликација, за оваа цел се користи алатка наречена kaniko, која е специјално направена за градење на слики за контејнери, оваа алатка лесно се интегрирана во Kubernetes платформата и овозможува градење на слики без потреба од Docker инсталација, или посебна алатка за оваа цел.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\linewidth]{assets/base-image-view.png}
  \caption{Преглед на основните шаблони за градење на апликации}
  \label{fig:base-image-view}
\end{figure}

Администратор има можност да ги прилагоди потребните параметри за градење на апликацијата, овие се во целосна контрола на администратор и се претставуваат на корисникот како што се дефинирани, полињата може да се видат на слика \ref{fig:base-image-jar-app-props}. и слика \ref{fig:base-image-java-tool-props}. Во слика \ref{fig:base-image-jar-app-props}. се прикажани полињата потребни за градење на Java апликација со извршна датотека, каде администраторот им дава избор за прикачување на датотека на корисникот, додека на корисничка страна добива соодветно поле за оваа намена, а останатите се аргументите кои ќе бидат пратени кон самата апликација, ова служи за во случај на корисникот да му е потребно да ја прилагоди Java виртуелната машина (JVM), бидејќи тоа не би можел да го направи во наредниот чекор при хостирање.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\linewidth]{assets/base-image-jar-app.png}
  \caption{Преглед на опциите потребни за градење на Java апликација со извршна датотека}
  \label{fig:base-image-jar-app-props}
\end{figure}

На слика \ref{fig:base-image-java-tool-props}. се прикажани полињата потребни за градење на Java апликација со користење на алатка за изградба на извршна датотека, оваа слика конкретно се однесува на Gradle алатката, но сликата е доста специфична и од корисникот се бара git репозиториум, но самиот шаблон не имплементира автентикација, ова би можело да се додади како дополниетелно функционалност од страна на администраторот, при што би се додале дополнителни полиња за оваа намена, потоа во зависност од имплементацијата на шаблонот, администраторот исто така им дозволува на корисниците да испратат аргументи при градење на апликација, со што се дозволува поголема флексибилност при градење на апликации, и исто како и претходниот случај се дава на корисникот можност да се пратат аргументи со кои се прилагодува однесувањето на Java виртуелната машина.

На слика \ref{fig:base-image-edit}. е прикажан прегледот за прилагодување на шаблонот, при тоа на оваа страница администраторот има можност да внесе јазик, доколку не постои можe да внесе било каква вредност, откако се зачува новиот јазик или новата верзија, корисниците автоматски имаат пристап до новиот јазик или верзија внесена од страна на администраторот.

Администраторот има можност да додава и одзема полиња од шаблонот, при што сите овие промени се рефлектираат кај корисниците, кои при следното градење на апликација ќе ги добијат новите полиња, сите полиња кои се наведени од администратор може да со истото име да се користат во самиот шаблон за градење, како што е прикажано во код \ref{kod:gradle-build-dockerfile}, овие вредности се праќаат директно до алатката за градење на апликации.

Во случај да администраторот направи промени, сите постоечки апликации кои веќе се изградени си остануваат да постојат, но секоја наредна верзија од истата апликација што би се градела од страна на корисникот ќе се користи новиот шаблон, со што корисниците потребно е да ги внесат променетите аргументи, заради оваа причина треба од страна на администраторот да се внимава при правење на промени во постоечки шаблони.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\linewidth]{assets/base-image-gradle-app.png}
  \caption{Преглед на опциите потребни за градење на Java апликација со користење на алатка за изградба на извршна датотека}
  \label{fig:base-image-java-tool-props}
\end{figure}

Прикажано со код \ref{kod:gradle-build-dockerfile} е една целина за градење на Java апликација со користење на Gradle алатката, овој шаблон е прилагоден да ги користи аргументите кои се наведени на слика \ref{fig:base-image-java-tool-props}. притоа може да се забележи дека градењето е поделено на четири делови:

\begin{enumerate}
  \item Преземање на изворниот код од git репозиториумот.
  \item Градење на извршната датотека со користење на Gradle.
  \item Градење на минимална Java извршна околина (JRE) со користење на jlink.
  \item Креирање на финална слика за контејнер со вметнување на извршната датотека и Java извршната околина.
\end{enumerate}

Овие чекори се дефинирани од страна на администратор и не се задолжително, доколку администраторот одлучи да го промени шаблонот основните слики што се користат можe да ги замени со други, исто така одлуката дали ќе се изгради Java извршна околина или би се користела Java развојната околина (JDK) е во целосна контрола на администратор.

 \begin{lstlisting}[language=bash, caption={Шаблон за изградба на Java извршна датотека користејќи Gradle}, label={kod:gradle-build-dockerfile}]
    # 1.
    FROM alpine/git:2.45.2 as src

    WORKDIR /data

    ARG HASH
    ARG URL

    ENV HASH=${HASH}
    RUN git clone $URL src

    # 2.
    FROM gradle:8.9.0-jdk21-alpine as builder

    ARG JAR_PATH
    ARG BASE_DIRECTORY="."
    ARG BUILD_ARGS=""

    WORKDIR /data

    COPY --from=src /data/src src

    WORKDIR /data/src/$BASE_DIRECTORY

    RUN gradle $BUILD_ARGS clean build
    RUN mv $JAR_PATH /data/app.jar

    # 3.
    FROM eclipse-temurin:21-alpine as jrebuilder

    WORKDIR build

    RUN jlink \
        --add-modules ALL-MODULE-PATH \
        --strip-debug \
        --no-man-pages \
        --no-header-files \
        --output jre

    # 4.
    FROM alpine:3.20.2

    COPY --from=jrebuilder /build/jre jre
    COPY --from=builder  /data/app.jar app.jar

    ENV JAVA_ARGS ""
    ENV JAR_ARGS ""

    ENV JAVA_HOME /jre
    ENV PATH $JAVA_HOME/bin:$PATH

    CMD java $JAVA_ARGS -jar $JAR_ARGS app.jar
    \end{lstlisting}

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\linewidth]{assets/base-image-edit.png}
  \caption{Преглед за прилагодување на шаблонот за градење на апликација}
  \label{fig:base-image-edit}
\end{figure}

\subsection{Администрација на извршни датотеки}

Прегледот за администрација на извршни датотеки е прикажан на слика \ref{fig:admin-storage-view}. Овој преглед е достапен само до администраторот на платформата, при што администраторот има можност да ги брише сите извршни датотеки кои се зачувани во системот, овие извршни датотеки се користат при градење на слики за контејнери, и откако една слика е изградена извршната датотека повеќе не е потребна, заради оваа причина администраторот има можност да ги брише овие извршни датотеки и да ослободи простор на дискот.

Исто така во позадина апликацијата секој ден извршува чистење на извршни датотеки кои се постари од 1 ден, со што се овозможува автоматско одржување на системот и ослободување на простор на дискот. Ова е возможно бидејќи секоја извршна датотека се користи само при градење на слика за контејнер, и потоа не е возможно да се искористи од страна на корисникот. Со што оваа датотека останува на системот, При тоа заради една употреба не би имало смисла да се чува подолго време.

Но оваа функционалност е овозможена во случај да некој корисник постави извршна датотека која е преголема и прави проблеми, администраторот веднаш би можел да ја избрише таа извршна датотека и да ослободи простор на дискот.

Откако се искористи извршната датотека за градење на сликата потоа е невозможно истата да се види од кој корисник доаѓа, но за таа цел се користи патеката на извршната датотека, при секое зачувување на извршна датотека истата се зачувува во папка која го содржи уникатниот идентификатор на корисникот, при тоа полето за пребарување дозволува пребарување по патеката на извршната датотека, што овозможува администраторот да ја најде извршната датотека која сака да ја избрише според уникатниот идентификатор или името на апликацијата.

Голем предизвик тука беше што датотеките се менаџираат од страна на алатката која се користи за чување на датотеки, а тоа е WebDAV серверот, при што не постои директен пристап до датотеките, туку се користи WebDAV клиент\cite{sardine_github} за оваа намена, што го отежнува процесот на менаџирање на овие извршни датотеки.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\linewidth]{assets/admin-storage.png}
  \caption{Преглед за администрација на извршни датотеки}
  \label{fig:admin-storage-view}
\end{figure}

\subsection{Администрација на регистарот за слики}

На следниот преглед прикажан на слика \ref{fig:admin-registry-view}. е прикажан прегледот за администрација на регистарот на слики, овој преглед е достапен само до администраторот на платформата, при што администраторот има можност да ги брише сите слики кои се зачувани во регистарот на слики, овие слики се користат при хостирање на апликации, но откако сликата се избриши поради какви било причини, таа слика повеќе не е достапна за користење, и доколку дојде до рестарт на апликациите што ја хостираат оваа слика апликациите повеќе нема да можат да се стартуваат. Но ова би било видливо и од страна на корисникот, при што од негова страна нема да се појави избришаната слика во прегледот на изградените слики \ref{fig:releases}.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\linewidth]{assets/admin-registry-view.png}
  \caption{Преглед за администрација на регистарот на слики}
  \label{fig:admin-registry-view}
\end{figure}

На овој преглед администраторот може да ги види апликациите или сликите на сите корисници на апликацијата, и тука се добива исто така, доколку е достапно и името на корисникот кој ја има креирано оваа слика, ова е прикажано на слика \ref{fig:admin-registry-details} и слика \ref{fig:admin-registry-view}.

За овој преглед се користат истите податоци што се претставени за апликацијата или сликите на корисникот прикажани на слика \ref{fig:releases}, при што администраторот има можност да ги брише сите слики, без разлика кој корисник ја има креирано истата, но обичен корисник има можност да ја избрижи единствено својата слика.

При бришење на слика од регистарот на слики, главна цел не беше да се избриши сликата само од базата на податоци, туку и да се избриши сликата од страна на регистарот, за оваа цел се користи интерфејсот на искористениот регистар за слики, притоа комуникацијата се одвиваше со користење на Spring WebFlux клиент\cite{spring_web_flux}.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\linewidth]{assets/admin-registry-details.png}
  \caption{Преглед за администрација на регистарот на слики}
  \label{fig:admin-registry-details}
\end{figure}

\subsection{Преглед за документација}

Прегледот за документација е прикажан на слика \ref{fig:documentation}. Овој преглед е достапен за сите корисници на апликацијата, при што корисниците имаат можност да ја видат документацијата за користење на апликацијата, дополнително како да конфигурираат Java апликации, системите за градење на Java апликации, како и објаснување за тоа што се сервиси и како се поврзуваат повеќе апликации.

\begin{figure}
  \centering
  \includegraphics[width=1\linewidth]{assets/documentation.png}
  \caption{Преглед за документација}
  \label{fig:documentation}
\end{figure}

\subsection{Позадина на апликацијата}

Апликацијата во позадина исто така нуди апликациски интерфејс (API) кој овозможува целосно управување со сите функционалности кои се достапни преку корисничкиот интерфејс, но нуди и поддршка за покомплицирани сценарија, како што се креирање на повеќе подови во рамки на едно распоредување, или користење на посебни конфигурациски датотеки за самата апликација.

Апликацијата е обезбедена со системот за автентикација keycloak, при што за одредени барања е потребно корисникот да биде автентициран, за оваа цел се користи OpenID Connect протоколот, при што корисникот добива токен кој го користи за автентикација на барањата, овој протокол го користи Oauth2 при што апликацијата со користење на Oauth2 сервиси пристапува до keycloak и се добива токен со кој се проверува до што точно има пристап одреден корисник. Одредени барања се исклучиво достапни само до администраторот на апликацијата, при што се користи улогата која е доделена на корисникот за да се одреди дали корисникот има пристап до одредени ресурси.

Апликацијата поддржува автоматско чистење на ресурси кои не се користат, при што секој ден се бришат извршни датотеки кои се постари од 1 ден, со што се овозможува ослободување на простор на дискот. Исто така доколку е избришана слика од регистарот на слики, во регистарот остануваат податоци кои не се чистат автоматски, и се повикува команда од платформата за хостирање на апликации (Kubernetes) кон регистарот за да се избришат сите несакани податоци.

Додека апликацијата гради слики за контејнери, апликацијата ги складира сите податоци за одредена изградба на сликата во кеш меморија на самата апликација, поради тоа овозможено е следење на статусот на градењето, како и прикажување на логови во реално време до корисникот, овие податоци се чуваат само додека трае процесот на градење, откако сликата е изградена овие податоци се бришат од кеш меморијата, но логовите од градењето се зачувуваат во базата на податоци за понатамошно прегледување од страна на корисникот. Сликите се градат асинхроно, при што корисникот не мора да чека додека сликата се изгради, туку може да продолжи со користење на апликацијата и да прегледува други делови од апликацијата, додека во позадина се гради сликата\cite{spring_async}.

Апликацијата исто така менаџира распоредување во кеш меморијата, односно откако корисник креира распоредување на апликација, одредени податоци се чуваат во кеш меморијата за пристап до статусот на апликацијата. Потоа овие податоци се претставуваат на корисник со користење на веб сокети, при што корисникот добива известување во реално време за статусот на својата апликација.

