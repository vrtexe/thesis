\section{Користени технологии и библиотеки}

\subsection{Kotlin}
\includegraphics[height=4ex]{assets/KotlinLogo.png}

Kotlin претставува модерен програмски јазик кој се извршува на Java виртуелната машина (JVM), и се смета за алтернатива на Java, кој во споредба со Kotlin се движи побавно и се грижи доста за компатибилноста со претходните верзии. Kotlin е дизајниран од ново во помодерно време и го нема зад себе истиот багаж како Java. Но во споредба со Java е доста покомплициран, и се фокусира на недостатоците на Java заради кои превзема доста карактеристики од други јазици кои доста го модернизираат јазикот, направен е поекспресивен и поконцизен.

Една голема предност пред Java е тоа што Kotlin нуди поголема безбедност при ракување со null вредности, што е чест извор на грешки во Java апликациите. Kotlin има вграден систем за типови кој го прави речиси невозможно да се појави NullPointerException. Kotlin исто така поседува првокласна поддршка за функционално програмирање, овозможувајќи на дефинирање на методи надвор од класи, екстензибилни функции кои се надоврзуваат на постоечки типови, и користење на ламбда изрази за пофлексибилно работење со колекции. Исто така и колекциите во Kotlin се многу поекспресивни и нудат повеќе функционалности во споредба со Java. Во Kotlin нема потреба од користење на стримови за работа со колекции, бидејќи колекциите имаат вградени методи за филтрирање, мапирање и агрегација на податоци.

Kotlin е целосно компатибилен со Java, што значи дека може да се користи заедно со постоечки Java библиотеки, и ова му овозможува лесен премин од Java кон Kotlin. Нема големи ограничувања и брзината е иста како Java. Kotlin е доволно зрел јазик, и до овој момент е доста компатибилен со останати Java технологии, и има голема заедница која го користи и развива.

\subsection{Gradle}
\includegraphics[height=4ex]{assets/GradleLogo.png}

Gradle\cite{gradle_documentation} е современ систем за автоматизација на градење кој се користи за управување со процесот на градење, тестирање и распоредување на софтверски проекти. Gradle е дизајниран да биде флексибилен и моќен, овозможувајќи на развивачите да дефинираат сложени градежни процеси преку така наречен DSL (Domain-Specific Language), за оваа намена Gradle дозволува користење на Groovy или Kotlin како јазик за дефинирање на градежните скрипти.

Со овој пристап Gradle нуди целосна функционалност за прилагодување на процесот за градење според специфичните потреби на проектот. Gradle поддржува инкрементално градење, што значи дека само изменетите делови од проектот се повторно изградени, има добра интеграција со spring boot dev tools која е библиотека за подобрен развој на spring апликации, овозможувајќи побрзо време на развој и тестирање. Gradle има пристап до сите Java библиотеки преку кои доаѓаат преку Maven, но за разлика од Maven, Gradle овозможува поголема флексибилност и прилагодување на процесот на градење.

\subsection{Spring framework}
\includegraphics[height=4ex]{assets/SpringFrameworkLogo.png}

Spring рамката претставува еден од најпопуларните и најшироко користени рамки за развој на апликации во Java екосистемот. Тој обезбедува сеопфатен сет на алатки и библиотеки кои го олеснуваат развојот на модерни, скалабилни и одржливи апликации. Една од главните карактеристики на Spring е неговата модуларна архитектура, која овозможува на развивачите да ги изберат само оние компоненти кои им се потребни за нивната апликација. При тоа Spring нуди широк спектар на интеграции со различни технологии и библиотеки, што го прави лесно да се вклучат во апликацијата.

Една голема предност на Spring е неговата поддршка за инверзија на контрола (IoC) и зависноста на инјектирање (DI), што овозможува подобра модуларност и тестабилност на кодот. И сите интеграции со библиотеки се овозможени од страна на развивачите на Spring, доколку е потребно да се користи некоја технологија или библиотека, шансата да има веќе интеграција во Spring е многу голема.

Spring е алатка која го модернизира развивањето на апликации во Java екосистемот, во помодерно време Spring нуди доста добра интеграција и со Kotlin\cite{spring_kotlin_guide}, дозволувајќи пристап до Java екосистемот со помодерен јазик како што е Kotlin. Поради сите овие причини, Spring останува еден од најпопуларните избори за развој на апликации во Java и Kotlin.

\subsection{Svelte+kit}
\includegraphics[height=4ex]{assets/SvelteLogo.png}

Svelte\cite{svelte_documentation} е современ фронтенд фрејмворк кој се разликува од традиционалните фрејмворци како React или Angular по тоа што Svelte компајлира апликацискиот код во оптимизиран JavaScript код за време на изградбата, наместо да користи виртуелен DOM за ажурирање на корисничкиот интерфејс во реално време. Овој пристап резултира со побрзи перформанси и помалку трошоци за извршување.

SvelteKit\cite{svelte_kit_documentation} е рамка изградена врз основа на Svelte која обезбедува целосен сет на алатки за развој на веб апликации. SvelteKit нуди функционалности како што се серверско рендерирање (SSR), статичко генерирање на страници (SSG), и лесна интеграција со различни бекенд технологии. SvelteKit има поддршка за повеќе страници, додека Svelte е повеќе наменет за изработка на еднострани апликации (SPA), SvelteKit испраќа на корисниците компајлиран HTML и CSS, а JavaScript за одредени делови кои не може да се познати при компајлирање.

За хостирање SvelteKit нуди исто така хостирање на еднострана апликација, но нуди и хостирање на серверски рендерирана апликација (SSR) што овозможува подобра пребарувачка оптимизација (SEO) и побрзо време на вчитување на страниците.
SvelteKit користи рутирање базирано на датотеки и папки, што значи дека структурата на датотеките во проектот директно одговара на URL патеките на апликацијата. Ова го прави лесно за развивачите да креираат и управуваат со различни страници и руте во апликацијата, покрај \texttt{.svelte} датотеки, има поддршка за \texttt{.server.ts} датотеки кои дозволуваат на дефинирање на апликациски интерфејс и служат како замена за контролери во Spring.

За хостирање на апликацијата потребно е да се има посебно распоредување само за корисничкиот интерфејс, ова најчесто значи дека има уште еден посветен Node.js сервер кој ќе се грижи за хостирање на корисничкиот интерфејс. При тоа треба доста да се внимава на тоа кој дел се извршува на страна на клиентот, а кој дел би се извршил на страна на серверот, како еден недостаток ова знае да биде доста комплицирано за нови корисници, и не е секогаш јасно кој дел од кодот е извршен на страна на серверот.

Голема предност е самата синтакса на Svelte, која е многу поедноставна и поекспресивна во споредба со други кориснички рамки. Svelte користи декларативен пристап за дефинирање на корисничкиот интерфејс, кодот се сместува во една датотека која содржи HTML, CSS и JavaScript, што го прави полесно за читање и одржување на кодот и тоа претставува една компонента, Svelte исто така овозможува полесно чување на состојбата на апликацијата, и овие споделени делови можe да се стават во посебни датотеки кои се викаат складови (store), со овој пристап голема предност е тоа што за разлика од React нема потреба од заеднички елемент во рамки на дрвото на компоненти за да овозможи пристап до иста состојба.

\subsection{Kubernetes}
\includegraphics[height=4ex]{assets/KubernetesLogo.png} \includegraphics[height=3ex]{assets/KubernetesName.png}

Kubernetes\cite{kubernetes_website} претставува платформа со отворен код за оркестрација и управување со контејнеризирани апликации. Тој обезбедува автоматизација на процесите на распоредување, скалирање и управување со апликации во контејнерски средини. Kubernetes овозможува на развивачите и администраторите да ги менаџираат своите апликации на ефикасен начин, без разлика дали се работи за мали или големи инфраструктури.

Во Kubernetes една апликација се состои од повеќе компоненти, како што се капсули (pods), сервиси (services) и распоредувања (deployments). Капсулите се најмалата единица на распоредување во Kubernetes и поддржуваат извршување на еден или повеќе контејнери, додека контејнерите претставуваат изолиран систем во кој се извршува изградена слика од апликацијата. За пристап до капсулите се користат сервиси кои овозможуваат стабилен пристап до нив, додека распоредувањата управуваат со капсулите, овозможувајќи автоматско скалирање и ажурирање на апликациите.

Една клучна функционалност зошто Kubernetes беше избран е изолацијата на апликациите преку Namespaces, што овозможува на различни апликации да се изолираат една од друга, со што се избегнуваат конфликти помеѓу клиенти. Исто така Kubernetes нуди автоматско скалирање на апликациите врз основа на оптоварувањето, што овозможува оптимално користење на ресурсите и подобри перформанси, и сето ова можe да се контролира со ресурси дифинирани со користење yaml јазикот. Покрај тоа Kubernetes обезбедува апликациски интерфејс за интеракција со платформата, со што се овозможува контрола преку главната апликација.

За интеракција со Kubernetes кластерот беше користена библиотеката \texttt{java-kubernetes-client}\cite{kubernetes_java_client}, која овозможува лесна интеграција со Кotlin и Java апликации. Со оваа библиотека можи да се креираат, бришат и менаџираат сите ресурси во рамки на кластерот, овозможувајќи на главната апликација да комуницира со Kubernetes кластерот и да ги менаџира апликациите.

Дополнителни функционалности кои ги нуди Kubernetes се исто така хостирање на помошните сервиси за хостирање на апликациите, и вмрежување на апликациите преку вградени алатки како што се Ingress контролерите, кои овозможуваат управување со влезниот сообраќај кон апликациите.

Со користење на Kubernetes како платформа за хостирање на апликации, дозволува апликацијата да е директно врзана со платформата наместо со специфичен сервер или инфраструктура, што овозможува поголема флексибилност и скалабилност при хостирање на апликации во облак.

\subsection{PostgreSQL}
\includegraphics[height=14ex]{assets/PostgresqlLogo.png}

PostgreSQL\cite{postgresql} претставува објектно-релациски систем за управување со база на податоци (ORDBMS) со отворен код, кој е познат по својата стабилност, скалабилност и големиот број на функционалности што ги нуди. PostgreSQL е дизајниран да поддржува сложени податочни структури и операции, што го прави погоден за широк спектар на апликации, од мали веб апликации до големи корпоративни системи, доколку функционалноста не е достапна директно во системот, постојат додатоци кои го нудат тоа.

PostgreSQL поддржува различни типови на податоци, вклучувајќи стандардни типови како што се цели броеви, текст и датуми, како и напредни типови како што се JSON, XML и геопросторни податоци. Ова овозможува на развивачите да ги моделираат своите податоци на начин кој најдобро одговара на потребите на апликацијата.

Апликацијата немаше потреба од комплицирани податочни типови, но беше избран PostgreSQL поради големата заедницата позади него и стабилноста што ја нуди, како и лесната интеграција со Spring преку Spring Data JPA, што овозможува лесно управување со базата на податоци и извршување на операции како што се креирање, читање, ажурирање и бришење на податоци.

За миграции се користи алатката Liquibase, која овозможува управување со верзии на базата на податоци и автоматско извршување на миграции при стартување на апликацијата. Ова овозможува лесно одржување на структурата на базата на податоци помеѓу верзии на апликацијата и избегнување на конфликти при промени во шемата на базата на податоци.

\subsection{Keycloak}
\includegraphics[height=4ex]{assets/KeycloakLogo.png}

Keycloak\cite{keycloak} претставува платформа со отворен код за управување со идентитети и пристап (Identity and Access Management - IAM), кој обезбедува централизирана автентикација и авторизација, овој сервис има поддршка за повеќе современи и стандардни протоколи за автентикација како што се OAuth 2.0, OpenID Connect и SAML 2.0, овозможувајќи полесна интеграција со различни технологии и рамки, како што се Spring Security, што овозможува лесно управување со корисничките сесии и пристапот до заштитени ресурси.

Keycloak нуди богати функционалности за управување со корисници, групи и улоги, овозможувајќи на администраторите да дефинираат различни нивоа на пристап и дозволи за корисниците. Дополнително.

Keycloak исто така нуди поддршка за повеќе надворешни провајдери на автентикација, како што се Google, facebook, потоа LDAP и Azure AD (Active Directory), овозможувајќи на корисниците да се најавуваат користејќи ги своите постоечки сметки од овие платформи. Keycloak поседува доста голема мрежа на поддржани интеграции, кога се развива решение кое бара автентикација и авторизација, но истовремено не е јасно кој систем го користат клиенти, Keycloak претставува одлично решение за оваа намена, бидејќи не е врзано со одреден еко систем и може да се интегрира со различни платформи.

Keycloak својата состојба ја чува во релациска база на податоци, за оваа намена беше користен PostgreSQL. Додека во базата на податоци на апликацијата се чува само референца кон корисничкиот идентификатор добиен од Keycloak, што овозможува поврзување на корисникот со неговиот именски простор и апликациите што ги поседува. Овој пристап ја зголемува безбедноста и го поедноставува управувањето со корисничките податоци, поради тоа што keycloak се грижи за безбедноста на корисничките податоци, ова не е грижа за време на развој на апликацијата.

\subsection{Kaniko}
\includegraphics[height=4ex]{assets/Kaniko-Logo.png}

Kaniko\cite{kaniko_github} претставува алатка со отворен код наменета за градење на слики за контејнери директно во контејнеризирана околина, без потреба од инсталиран Docker daemon или привилегиран пристап до системот. Ова го прави Kaniko особено погоден за употреба во Kubernetes околини, каде што безбедносните ограничувања и изолацијата на процесите се од големо значење.

Kaniko поддржува градење на слики со користење на Dockerfile, што овозможува на развивачите да ги искористат своите постоечки знаења и алатки за градење на слики. Kaniko ги имплементира истиот формат и инструкции како Docker, но сепак има одредени разлики, шаблоните за сликите што ги одржува администратор се чуваат во базата и се праќаат на оваа алатка.

Kaniko е интегриран користејќи kubernetes задачи (jobs), што овозможува на апликацијата да иницира процес на градење на слики во рамки на платформата. Ова ја прави алатката независна од апликацијата, доколку друга алатка има поддршка за Dockerfile инструкции може лесно да се замени со друга алтернативна алатка за градење на слики.

\subsection{Docker registry v2}

Docker registry v2\cite{container_registry_api_v2} претставува сервис со отворен код за складирање и дистрибуција на Docker слики. Овој регистар овозможува на корисниците да ги зачуваат своите контејнерски слики на едно место, сервисите што ја користат оваа алатка можат лесно да ги повлечат сликите кога им се потребни во поддржаниот формат.

Бидејќи Docker registry v2 ги поддржува сите стандарди за контејнери, овозможува лесна интеграција со различни алатки и платформи за контејнери, како што се kaniko, алатката за градење на слики, која исто така е потребно да ги зачува изградените слики, Kubernetes главната платформа, која треба да ги повлечи сликите за да ги изврши апликациите, за повлекување може да се користи containerd, cri-o, и сите тие се поддржани бидејќи го имплементираат OCI (Open Container Initiative) спецификациите.

За комуникација со овој сервис беше искористена Spring ЊebФlux\cite{spring_web_flux}библиотеката, која овозможува лесна интеграција со Spring апликации и овозможува асинхроно ракување со HTTP барања.

\subsection{WebDAV}
\includegraphics[height=4ex]{assets/Webdav-logo.jpg}

WebDAV (Web Distributed Authoring and Versioning)\cite{webdav} претставува протокол кој овозможува на корисниците да управуваат со датотеки на далечински сервер преку HTTP. WebDAV додава дополнителни методи на HTTP протоколот, овозможувајќи операции како што се креирање, бришење, преместување и менување на датотеки и папки на серверот. WebDAV претставува спецификација која кажува како изгледаат повиците и податоците за датотеките, но имплементацијата може да варира, и постојат различни сервери што го имплементираат овој протокол.

За интеракција со WebDAV серверот беше користена библиотеката \texttt{Sardine}, која овозможува лесна интеграција со Кotlin и Java апликации. Со оваа библиотека може да се креираат, бришат и менаџираат датотеки и папки на WebDAV серверот, овозможувајќи на главната апликација да ги зачува извршните датотеки кои се користат при градење на слики за контејнери.

WebDAV беше избран затоа што беше потребно да се чуваат изградените извршни датотеки на корисниците, за потоа да бидат достапни при градењето на слики за контејнери. Со користење на WebDAV, извршните датотеки се зачувуваат на едно место, притоа со самото тоа што WebDAV е стандардизиран протокол, овозможува лесна интеграција со различни сервери и платформи, веќе постојат библиотеки за оваа намена, и ова ја прави апликацијата независна од самиот сервер што складира датотеки.

\subsection{WebSocket протоколот}

За увид во логови и следење на апликациите на корисниците беше потребно да се овозможи комуникација во реално време, за оваа намена беше користен WebSocket протоколот, кој овозможува двонасочна комуникација помеѓу клиентот и серверот преку една постојана врска. За оваа намена беше користена библиотеката \texttt{spring-boot-starter-websocket}\cite{spring_web_sockets}, која овозможува лесна интеграција со Spring апликации.

Доколку се иницира конекција преку WebSocket протоколот, серверот може да испраќа пораки до клиентот во реално време, без потреба клиентот постојано да праќа барања за ажурирање. Еден голем предизвик е тоа што во секое време има можност да се затвори конекцијата, и доколку се случи такво нешто потребно е да се чуваат одредени логови во базата на податоци од моменталната состојба.

Логовите за градење на сликата се испраќаат од капсулата на задачата што ја гради сликата, и овие логови може да се читаат користејќи го апликацискиот интерфејс на kubernetes, овие логови се испраќаат преку WebSocket протоколот до корисникот во реално време, но доколку се иницира конекцијата за прв пат, потребно е да се прати цела состојба до тој момент, а потоа може да се праќаат само ажурирани логови, доколку градењето е завршено логовите се складираат во базата на податоци и притоа не се користи WebSocket протоколот за оваа намена, туку само се земаат директно.

Статусот на апликациите се следи исто така преку апликацискиот интерфејс на kubernetes, и овие статуси се испраќаат преку WebSocket протоколот до корисникот во реално време, овие статуси се следат од страна на платформата, а платформата испраќа повици до апликацијата доколку се случи некој настан на страна на самата платформа, ова се случува само доколку барем еден клиент слуша за статусот на апликацијата.
